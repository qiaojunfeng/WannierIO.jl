var documenterSearchIndex = {"docs":
[{"location":"api/w90/#Wannier90-files","page":"Wannier90","title":"Wannier90 files","text":"","category":"section"},{"location":"api/w90/","page":"Wannier90","title":"Wannier90","text":"CurrentModule = WannierIO","category":"page"},{"location":"api/w90/","page":"Wannier90","title":"Wannier90","text":"warning: Warning\nSome of the functions, e.g. read_amn, write_amn, read_chk, write_chk, etc., support reading/writing Fortran unformatted files. However, the Fortran unformatted files are machine and compiler dependent. Therefore, it is not guaranteed that these functions work for all the cases. Currently, the functions are tested on the following platforms:Linux + gfortran 11.2","category":"page"},{"location":"api/w90/#Public-API","page":"Wannier90","title":"Public API","text":"","category":"section"},{"location":"api/w90/","page":"Wannier90","title":"Wannier90","text":"Modules = [WannierIO]\nPrivate = false\nPages   = map(file -> joinpath(\"w90\", file), readdir(\"../src/w90\"))","category":"page"},{"location":"api/w90/#WannierIO.read_amn","page":"Wannier90","title":"WannierIO.read_amn","text":"read_amn(filename)\nread_amn(filename, ::FortranText)\nread_amn(filename, ::FortranBinaryStream)\n\nRead wannier90 amn file.\n\nReturn\n\nA: length-n_kpts vector, each element is a n_bands * n_wann matrix.\nheader: first line of the file\n\nNote there are three versions of this function: the 1st one is a wrapper function that automatically detect the format (text or binary) of the file, and does some additional pretty printing to give user a quick hint of the dimensions of the A matrix; it internally calls the 2nd or the 3rd version for actual reading.\n\nWannier90 only has Fortran text format for amn, however I wrote a custom version of QE pw2wannier90.x that can output Fortran binary format (using Fortran stream IO) to save some disk space. The 1st function auto detect the file format so it is transparent to the user.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_amn","page":"Wannier90","title":"WannierIO.write_amn","text":"write_amn(filename, A; header=default_header(), binary=false)\nwrite_amn(filename, A, ::FortranText; header=default_header())\nwrite_amn(filename, A, ::FortranBinaryStream; header=default_header())\n\nWrite wannier90 amn file.\n\nArguments\n\nfilename: output filename\nA: a length-n_kpts vector, each element is a n_bands * n_wann matrix\n\nKeyword arguments\n\nheader: 1st line of the file\nbinary: write as Fortran unformatted file, which is the Wannier90 default.   Here the binary kwargs is provided for convenience.\n\nSame as read_amn there are three versions of this function, the 1st one is a wrapper function, it calls the 2nd or the 3rd version depending on the binary kwargs.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_w90_band-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_band","text":"read_w90_band(prefix)\n\n\nRead prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat.\n\nArguments\n\nprefix: prefix of the filenames (or called seedname in wannier90), NOT the full filename.\n\nReturn\n\nx: n_kpts, x axis value of kpath, in cartesian length\neigenvalues: length-n_kpts vector, each element is a length-n_bands vector of band energies\nkpoints: a vector of length n_kpts, fractional coordinates\nkweights: a vector of length n_kpts, weights of kpoints\nsymm_point_indices: index of high-symmetry points in prefix_band.dat\nsymm_point_labels: name of high-symmetry points\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_w90_band_dat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_band_dat","text":"read_w90_band_dat(filename)\n\n\nRead prefix_band.dat file generated by wannier90.x, or prefix-band.dat file generated by postw90.x.\n\nReturn\n\nx: n_kpts, x axis value of kpath, in cartesian length\neigenvalues: length-n_kpts vector, each elemnt is a length-n_bands vector   of band energies\nextras: optional (the postw90.x might generate a file with a third column),   same size as eigenvalues, often the color of each eigenvalue,   e.g., spin projection\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_w90_band_kpt-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_band_kpt","text":"read_w90_band_kpt(filename)\n\n\nRead a prefix_band.kpt file.\n\nReturn\n\nkpoints: a vector of length n_kpts, fractional coordinates\nkweights: a vector of length n_kpts, weights of kpoints\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_w90_band_labelinfo-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_band_labelinfo","text":"read_w90_band_labelinfo(filename)\n\n\nRead prefix_band.labelinfo file.\n\nReturn\n\nsymm_point_indices: index of high-symmetry points in prefix_band.dat\nsymm_point_labels: name of high-symmetry points\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_band-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_band","text":"write_w90_band(\n    prefix;\n    x,\n    eigenvalues,\n    kpoints,\n    kweights,\n    symm_point_indices,\n    symm_point_labels\n)\n\n\nWrite prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat.\n\nArguments\n\nprefix: prefix of prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat\n\nKeyword Arguments\n\nx: n_kpts, x axis value, in cartesian length\neigenvalues: length-n_kpts vector, each element is a length-n_bands vector of band energies\nkpoints: length-n_kpts vector, fractional coordinates\nkweights: a vector of length n_kpts, weights of kpoints\nsymm_point_indices: index of high-symmetry points in prefix_band.dat\nsymm_point_labels: name of high-symmetry points\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_band_dat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_band_dat","text":"write_w90_band_dat(filename; x, eigenvalues, extras)\n\n\nWrite prefix_band.dat file.\n\nArguments\n\nfilename: filename of prefix_band.dat\n\nKeyword Arguments\n\nx: n_kpts, x axis value, in cartesian length\neigenvalues: length-n_kpts vector, each element is a length-n_bands   vector of band energies\nextras: optional, same size as eigenvalues, will be written as the third   column of prefix_band.dat. The prefix-band.dat file generated by   postw90.x sometimes has a third column for e.g. the color of the eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_band_kpt-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_band_kpt","text":"write_w90_band_kpt(filename; kpoints, kweights)\n\n\nWrite prefix_band.kpt file.\n\nArguments\n\nfilename: filename of prefix_band.kpt\n\nKeyword Arguments\n\nkpoints: length-n_kpts vector, fractional coordinates\nkweights: n_kpts, optional, weights of kpoints, default to 1.0.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_band_labelinfo-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_band_labelinfo","text":"write_w90_band_labelinfo(\n    filename;\n    x,\n    kpoints,\n    symm_point_indices,\n    symm_point_labels\n)\n\n\nWrite prefix_band.labelinfo file.\n\nArguments\n\nfilename: filename of prefix_band.labelinfo\n\nKeyword Arguments\n\nx: n_kpts-vector, x axis value, in cartesian length\nkpoints: length-n_kpts vector, fractional coordinates\nsymm_point_indices: index of high-symmetry points in prefix_band.dat\nsymm_point_labels: name of high-symmetry points\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.get_U-Tuple{WannierIO.Chk}","page":"Wannier90","title":"WannierIO.get_U","text":"get_U(chk)\n\n\nExtract the combined U = Udis * Uml matrices from Chk.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.get_Udis-Tuple{WannierIO.Chk}","page":"Wannier90","title":"WannierIO.get_Udis","text":"get_Udis(chk)\n\n\nExtract disentanglement Udis matrices from Chk.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_chk-Tuple{AbstractString, WannierIO.FortranText}","page":"Wannier90","title":"WannierIO.read_chk","text":"read_chk(filename)\nread_chk(filename, ::FortranText)\nread_chk(filename, ::FortranBinary)\n\nRead wannier90 chk checkpoint file.\n\nSimilar to read_amn, the 1st version auto detect chk file format (binary or text) and read it.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_chk","page":"Wannier90","title":"WannierIO.write_chk","text":"write_chk(filename, chk::Chk; binary=false)\nwrite_chk(filename, chk::Chk, ::FortranText)\nwrite_chk(filename, chk::Chk, ::FortranBinary)\n\nWrite wannier90 chk file.\n\nSimilar to write_amn, the 1st version is a convenience wrapper.\n\nKeyword arguments\n\nbinary: write as Fortran binary file or not. Although wannier90 default   is Fortran binary format, here the default is false since Fortran binary   depends on compiler and platform, so it is not guaranteed to always work.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_eig","page":"Wannier90","title":"WannierIO.read_eig","text":"read_eig(filename)\nread_eig(filename, ::FortranText)\nread_eig(filename, ::FortranBinaryStream)\n\nRead the wannier90 eig file.\n\nReturn\n\neigenvalues: a lenth-n_kpts vector, each element is a length-n_bands vector\n\nThe 1st version is a convenience wrapper function for the 2nd and 3rd versions.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_eig","page":"Wannier90","title":"WannierIO.write_eig","text":"write_eig(filename, eigenvalues; binary=false)\nwrite_eig(filename, eigenvalues, ::FortranText)\nwrite_eig(filename, eigenvalues, ::FortranBinaryStream)\n\nWrite eig file.\n\nArguments\n\neigenvalues: a length-n_kpts vector, each element is a length-n_bands vector\n\nKeyword arguments\n\nbinary: if true write in Fortran binary format.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_w90_hrdat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_hrdat","text":"read_w90_hrdat(filename)\n\n\nRead prefix_hr.dat.\n\nReturn\n\nRvectors: mathbfR-vectors on which operators are defined\nRdegens: degeneracies of each mathbfR-vector\nH: Hamiltonian mathbfH(mathbfR)\nheader: the first line of the file\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_hrdat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_hrdat","text":"write_w90_hrdat(filename; Rvectors, Rdegens, H, header)\n\n\nWrite prefix_hr.dat.\n\nKeyword arguments\n\nSee the return values of read_w90_hrdat.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_mmn","page":"Wannier90","title":"WannierIO.read_mmn","text":"read_mmn(filename)\nread_mmn(filename, ::FortranText)\nread_mmn(filename, ::FortranBinaryStream)\n\nRead wannier90 mmn file.\n\nReturn\n\nM: length-n_kpts vector, each element is a length-n_bvecs vector, then   each element is a n_bands * n_bands matrix\nkpb_k: length-n_kpts vector, each element is a length-n_bvecs vector of   integers for the indices of the neighboring kpoints\nkpb_G: length-n_kpts vector, each element is a lenght-n_bvecs vector of   of Vec3{Int}, which are the translation vectors\nheader: 1st line of the file\n\nThe translation vector G is defined as b = kpoints[kpb_k[ik][ib]] + kpb_G[ik][ib] - kpoints[ik], where b is the ib-th bvector of the ik-th kpoint.\n\nThe 1st version is a convenience wrapper for the other two.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_mmn","page":"Wannier90","title":"WannierIO.write_mmn","text":"write_mmn(filename; M, kpb_k, kpb_G; header=default_header(), binary=false)\nwrite_mmn(filename; M, kpb_k, kpb_G, ::FortranText; header=default_header(), binary=false)\nwrite_mmn(filename; M, kpb_k, kpb_G, ::FortranBinaryStream; header=default_header(), binary=false)\n\nWrite wannier90 mmn file.\n\nArguments\n\nfilename: output file name\nM: length-n_kpts vector of n_bands * n_bands * n_bvecs arrays\nkpb_k: length-n_kpts vector of length-n_bvecs vector of integers\nkpb_G: length-n_kpts vector of length-n_bvecs vector of Vec3{Int} for bvectors\n\nKeyword arguments\n\nheader: header string\nbinary: if true write in Fortran binary format\n\nThe 1st version is a convenience wrapper for the other two.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_nnkp","page":"Wannier90","title":"WannierIO.read_nnkp","text":"read_nnkp(filename)\nread_nnkp(filename, ::Wannier90Text)\nread_nnkp(filename, ::Wannier90Toml)\n\nRead wannier90 nnkp file.\n\nReturn\n\nlattice: each column is a lattice vector\nrecip_lattice: each column is a reciprocal lattice vector\nkpoints: length-n_kpts vector, each element is Vec3, in fractional coordinates\nkpb_k: length-n_kpts vector, each element is a length-n_bvecs vector of   integers, index of kpoints\nkpb_G: length-n_kpts vector, each element is a length-n_bvecs vector,   then each element is Vec3 for translations, fractional w.r.t recip_lattice\n\nWannier90 nnkp file is a plain text format, the 2nd version reads nnkp file in Wannier90 format. The thrid version read a TOML-format nnkp file, which is defined by this package, see write_nnkp. The 1st version auto detects the format and parse it.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_nnkp","page":"Wannier90","title":"WannierIO.write_nnkp","text":"write_nnkp(filename; toml=false, kwargs...)\nwrite_nnkp(filename, ::Wannier90Text; kwargs...)\nwrite_nnkp(filename, ::Wannier90Toml; kwargs...)\n\nWrite a nnkp file that can be used by DFT codes, e.g., QE pw2wannier90.\n\nKeyword Arguments\n\ntoml: write to a TOML file, otherwise write to a Wannier90 text file format\nrecip_lattice: each column is a reciprocal lattice vector\nkpoints: length-n_kpts vector of Vec3, in fractional coordinates\nkpb_k: length-n_kpts vector, each element is a length-n_bvecs vector of   integers, index of kpoints\nkpb_G: length-n_kpts vector, each element is a length-n_bvecs vector,   then each element is a Vec3 for translation vector, fractional w.r.t. recip_lattice\nn_wann: if given, write an auto_projections block\nexclude_bands: if given, write the specified band indices in the exclude_bands block\nheader: first line of the file\n\nnote: Note\nOnly use auto_projections, the projections block is not supported.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_w90_rdat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_rdat","text":"read_w90_rdat(filename)\n\n\nRead prefix_r.dat.\n\nReturn\n\nRvectors: mathbfR-vectors on which operators are defined\nr_x: x-component of position operator\nr_y: y-component of position operator\nr_z: z-component of position operator\nheader: the first line of the file\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_spn","page":"Wannier90","title":"WannierIO.read_spn","text":"read_spn(filename)\nread_spn(filename, ::FortranText)\nread_spn(filename, ::FortranBinary)\n\nRead the wannier90 spn file.\n\nReturn\n\nSx: spin x, a length-n_kpts vector, each element is a n_bands-by-n_bands matrix\nSy: spin y, a length-n_kpts vector, each element is a n_bands-by-n_bands matrix\nSz: spin z, a length-n_kpts vector, each element is a n_bands-by-n_bands matrix\nheader: 1st line of the file\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_spn","page":"Wannier90","title":"WannierIO.write_spn","text":"write_spn(filename, Sx, Sy, Sz; binary=false, header)\nwrite_spn(filename, Sx, Sy, Sz, ::FortranText; header)\nwrite_spn(filename, Sx, Sy, Sz, ::FortranBinary; header)\n\nWrite the spn file.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_w90_tbdat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_tbdat","text":"read_w90_tbdat(filename)\n\n\nRead prefix_tb.dat.\n\nReturn\n\nlattice: each column is a lattice vector in Å\nRvectors: mathbfR-vectors on which operators are defined\nRdegens: degeneracies of each mathbfR-vector\nH: Hamiltonian mathbfH(mathbfR)\nr_x: x-component of position operator\nr_x: y-component of position operator\nr_x: z-component of position operator\nheader: the first line of the file\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_tbdat-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_tbdat","text":"write_w90_tbdat(\n    filename;\n    lattice,\n    Rvectors,\n    Rdegens,\n    H,\n    r_x,\n    r_y,\n    r_z,\n    header\n)\n\n\nWrite prefix_tb.dat.\n\nKeyword arguments\n\nSee the return values of read_w90_tbdat.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_uHu","page":"Wannier90","title":"WannierIO.read_uHu","text":"read_uHu(filename)\nread_uHu(filename, ::FortranText; transpose_band_indices=true)\nread_uHu(filename, ::FortranBinary; transpose_band_indices=true)\n\nRead the wannier90 uHu file.\n\nKeyword Arguments\n\ntranspose_band_indices: QE pw2wannier90.x writes the matrix in a strange   transposed manner; if reading a QE-generated uHu file, this flag should   be true to restore the band indices order, so that the returned matrix   has the correct order, i.e.,   uHu[ik][ib1, ib2][m, n] is   langle u_m k + b_1 H  u_n k + b_2 rangle\n\nReturn\n\nuHu: a length-n_kpts vector, each element is a n_bvecs * n_bvecs matrix,   then each element is a  n_bands * n_bands matrix\nheader: 1st line of the file\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_uHu","page":"Wannier90","title":"WannierIO.write_uHu","text":"write_uHu(filename, uHu; binary=false, header)\nwrite_uHu(filename, uHu, ::FortranText; header)\nwrite_uHu(filename, uHu, ::FortranBinary; header)\n\nWrite the uHu file.\n\nKeyword Arguments\n\ntranspose_band_indices: see read_uHu\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_unk","page":"Wannier90","title":"WannierIO.read_unk","text":"read_unk(filename)\nread_unk(filename, ::FortranText)\nread_unk(filename, ::FortranBinary)\n\nRead wannier90 UNK file for the periodic part of Bloch wavefunctions.\n\nReturn\n\nik: k-point index, start from 1\nΨ: periodic part of Bloch wavefunctions in real space,   size = (n_gx, n_gy, n_gz, n_bands, n_spin)\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_unk","page":"Wannier90","title":"WannierIO.write_unk","text":"write_unk(filename, ik, Ψ; binary=false)\nwrite_unk(filename, ik, Ψ, ::FortranText)\nwrite_unk(filename, ik, Ψ, ::FortranBinary)\n\nWrite UNK file for the periodic part of Bloch wavefunctions.\n\nArguments\n\nik: at which kpoint? start from 1\nΨ: Bloch wavefunctions, size(Ψ) = (n_gx, n_gy, n_gz, n_bands, n_spin)\n\nKeyword arguments\n\nbinary: write as Fortran unformatted file\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_win","page":"Wannier90","title":"WannierIO.read_win","text":"read_win(filename; fix_inputs=true)\nread_win(filename, ::Wannier90Text; fix_inputs=true)\nread_win(filename, ::Wannier90Toml; fix_inputs=true)\n\nRead wannier90 input win file.\n\nArguments\n\nfilename: The name of the input file.\n\nKeyword Arguments\n\nfix_inputs: sanity check and fix the input parameters, e.g., set   num_bands = num_wann if num_bands is not specified,   convert atoms_cart always to atoms_frac, etc.   See also fix_win!.\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.write_win","page":"Wannier90","title":"WannierIO.write_win","text":"write_win(filename; toml=false, kwargs...)\nwrite_win(filename, ::Wannier90Text; kwargs...)\nwrite_win(filename, ::Wannier90Toml; kwargs...)\n\nWrite input parameters into a wannier90 win file.\n\nThe input parameters are keyword arguments, with key names same as that of wannier90.\n\nExamples\n\nusing WannierIO\n\nwrite_win(\n    \"silicon.win\";\n    num_wann=4,\n    num_bands=4,\n    # unit_cell_cart is a matrix, its columns are the lattice vectors in angstrom\n    unit_cell_cart=[\n        0.0      2.71527  2.71527\n        2.71527  0.0      2.71527\n        2.71527  2.71527  0.0\n    ],\n    # atoms_frac is a vector of pairs of atom_label and fractional coordinates\n    atoms_frac=[\n        :Si => [0.0, 0.0, 0.0],\n        :Si => [0.25, 0.25, 0.25],\n        # both `:Si` and `\"Si\"` are allowed\n        # \"Si\" => [0.25, 0.25, 0.25],\n    ],\n    # each element in projections will be written as a line in the win file\n    projections=[\n        \"random\",\n    ]\n    kpoint_path=[\n        [:G => [0.0, 0.0, 0.0], :X => [0.5, 0.0, 0.5]],\n        [:X => [0.5, 0.0, 0.5], :U => [0.625, 0.25, 0.625]],\n    ],\n    mp_grid=[2, 2, 2],\n    # kpoints is a matrix, its columns are the fractional coordinates\n    kpoints=[\n        [0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.5],\n        [0.0, 0.5, 0.0],\n        [0.0, 0.5, 0.5],\n        [0.5, 0.0, 0.0],\n        [0.5, 0.0, 0.5],\n        [0.5, 0.5, 0.0],\n        [0.5, 0.5, 0.5],\n    ],\n    # additional parameters can be passed as keyword arguments, e.g.,\n    num_iter=500,\n)\n\n\n\n\n\n","category":"function"},{"location":"api/w90/#WannierIO.read_wout-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_wout","text":"read_wout(filename)\n\n\nParse wannire90 wout file.\n\nReturn\n\nlattice: each column is a lattice vector in Å\nrecip_lattice: each column is a reciprocal lattice vector in Å⁻¹\natom_labels: atomic symbols\natom_positions: in fractional coordinates\ncenters: final each WF centers in Å\nspreads: final each WF spreads in Å²\nΩI, ΩD, ΩOD, Ωtotal: final spread (components) in Å²\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.read_w90_wsvec-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.read_w90_wsvec","text":"read_w90_wsvec(filename)\n\n\nRead prefix_wsvec.dat.\n\nReturn\n\nmdrs: whether use MDRS interpolation, i.e. the use_ws_distance in the header\nRvectors: the mathbfR-vectors\nTvectors: the mathbfT_m n mathbfR-vectors.   Returned only mdrs = true.\nTdegens: the degeneracies of mathbfT_m n mathbfR-vectors.   Returned only mdrs = true.\nn_wann: number of WFs\nheader: the first line of the file\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_w90_wsvec-Tuple{AbstractString}","page":"Wannier90","title":"WannierIO.write_w90_wsvec","text":"write_w90_wsvec(\n    filename;\n    Rvectors,\n    n_wann,\n    Tvectors,\n    Tdegens,\n    header\n)\n\n\nWrite prefix_wsvec.dat.\n\nKeyword Arguments\n\nn_wann: for Wigner-Seitz Rvectors, needs to provide a n_wann for number of   Wannier functions; for MDRS Rvectors, the n_wann is optional and can be   automatically determined from the Tvectors\nTvectors and Tdegens: if provided, write in MDRS format; otherwise, write in   Wigner-Seitz format\n\nAlso see the return values of read_w90_wsvec.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#Private-API","page":"Wannier90","title":"Private API","text":"","category":"section"},{"location":"api/w90/","page":"Wannier90","title":"Wannier90","text":"These are some lower-level types/functions that are (probably) less used, thus not exported. Of course, you can still use them by prefixing WannierIO., e.g., WannierIO.read_w90_band_dat(filename).","category":"page"},{"location":"api/w90/","page":"Wannier90","title":"Wannier90","text":"Modules = [WannierIO]\nPublic = false\nPages   = map(file -> joinpath(\"w90\", file), readdir(\"../src/w90\"))","category":"page"},{"location":"api/w90/#WannierIO.default_band_kpt_kweights-Tuple{AbstractVector}","page":"Wannier90","title":"WannierIO.default_band_kpt_kweights","text":"default_band_kpt_kweights(kpoints)\n\n\nWannier90 default kweights in prefix_band.kpt is all 1.0.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.Chk","page":"Wannier90","title":"WannierIO.Chk","text":"Struct for storing matrices in prefix.chk file.\n\nstruct Chk{T<:Real}\n\nOne-to-one mapping to the wannier90 chk file, but renaming the variable names so that they are consistent with the rest of the code.\n\nFields\n\nheader: The header line, usually contains date and time\nn_bands: number of bands, can be auto set in constructor according to dimensions of other variables\nn_exclude_bands: number of excluded bands, can be auto set in constructor\nexclude_bands: Indices of excluded bands, starts from 1. Vector of integers, size: n_exclude_bands\nlattice: Matrix of size 3 x 3, each column is a lattice vector in Å unit\nrecip_lattice: Matrix of size 3 x 3, each column is a reciprocal lattice vector in Å⁻¹ unit\nn_kpts: number of kpoints, can be auto set in constructor\nkgrid: dimensions of kpoint grid, 3 integers\nkpoints: kpoint coordinates, fractional, length-n_kpts vector\nn_bvecs: number of b-vectors, can be auto set in constructor\nn_wann: number of Wannier functions, can be auto set in constructor\ncheckpoint: a string to indicate the current step (after disentanglement, after maximal localization, ...) in wannier90\nhave_disentangled: Have finished disentanglement or not\nΩI: Omega invariant part of MV spreads, in Å² unit\ndis_bands: Indices of bands taking part in disentanglement, not frozen bands! length-n_kpts vector, each element is a length-n_bands vector of bool.\nThis is needed since W90 puts all the disentanglement bands in the first several rows of Udis, (and the first few columns of Udis are the frozen bands) so directly multiplying eigenvalues e.g. (Udis * U)' * diag(eigenvalues) * (Udis * U) is wrong!\n\nn_dis: number of bands taking part in disentanglement at each kpoint. can be auto set in constructor from dis_bands\nUdis: Semi-unitary matrix for disentanglement, length-n_kpts vector, each elment has size: n_bands x n_wann, i.e., the u_matrix_opt in wannier90\nUml: Unitary matrix for maximal localization, length-n_kpts vector, each element has size: n_wann x n_wann, i.e., the u_matrix in wannier90. The abbreviation ml stands for maximal localization, so as to differentiate from the (combined) unitary matrix U = Udis * Uml.\nM: Wannier-gauge overlap matrix, length-n_kpts vector of length-n_bvecs vector, each element is a matrix of size n_wann x n_wann, i.e., the m_matrix in wannier90\nr: Wannier function centers, length-n_wann vector, Cartesian coordinates in Å unit, i.e., the wannier_centres variable in wannier90\nω: Wannier function spreads, length-n_wann vector, Å² unit, i.e., the wannier_spreads variable in wannier90\n\n\n\n\n\n","category":"type"},{"location":"api/w90/#WannierIO.Chk-Tuple{AbstractString, AbstractVector{Int64}, AbstractMatrix, AbstractMatrix, AbstractVector{<:Integer}, AbstractVector, AbstractString, Bool, Real, AbstractVector{BitVector}, Vararg{AbstractVector, 5}}","page":"Wannier90","title":"WannierIO.Chk","text":"Chk(\n    header,\n    exclude_bands,\n    lattice,\n    recip_lattice,\n    kgrid,\n    kpoints,\n    checkpoint,\n    have_disentangled,\n    ΩI,\n    dis_bands,\n    Udis,\n    Uml,\n    M,\n    r,\n    ω\n)\n\n\nConvenience constructor of Chk struct that auto set some fields.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#Base.isapprox-Tuple{WannierIO.Chk, WannierIO.Chk}","page":"Wannier90","title":"Base.isapprox","text":"isapprox(a, b)\n\n\nCompare two Chk objects.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._check_eig_order-Tuple{AbstractVector}","page":"Wannier90","title":"WannierIO._check_eig_order","text":"_check_eig_order(eigenvalues; digits)\n\n\nCheck that eigenvalues are in order.\n\nSome times there are small noises, use digits to set the number of digits for comparisons.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._reshape_eig-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Wannier90","title":"WannierIO._reshape_eig","text":"_reshape_eig(idx_b, idx_k, eig)\n\n\nReshape a vector of eigenvalues into a matrix of eigenvalues.\n\nAuto detect the number of bands and kpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.write_HH_R-Union{Tuple{IT}, Tuple{T}, Tuple{AbstractString, AbstractArray{T, 3}, AbstractMatrix{IT}}} where {T<:Complex, IT<:Integer}","page":"Wannier90","title":"WannierIO.write_HH_R","text":"write_HH_R(filename, H, R; N, header)\n\n\nWrite the real space Hamiltonian to a prefix_HH_R.dat file.\n\nArguments\n\nfilename: usually prefix_HH_R.dat\nH: a n_wann * n_wann * n_rvecs array of Hamiltonian\nR: a n_rvecs * 3 array of integers\n\nKeyword arguments\n\nN: a n_rvecs vector of integers, the degeneracy of each R vector\nheader: a string, the header of the file\n\nnote: Note\nWanier90 postw90.x has a hidden input parameter effective_model, setting it to true and postw90.x will read this HH_R.dat to fill the real space Hamiltonian, and do subsequent Wannier interpolation, e.g., in BoltzWann. However, the vanila postw90.x code does not take into account the degeneracy of R vectors, and also does not use MDRS interpolation. I have modified the postw90.x code to use MDRS, and also changed a bit the number of digits for the Hamiltonian in HH_R.dat, so that it is the same as the prefix_tb.dat file, i.e., from Fortran F12.6 to E15.8.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._check_dimensions_M_kpb-Tuple{Any, Any, Any}","page":"Wannier90","title":"WannierIO._check_dimensions_M_kpb","text":"_check_dimensions_M_kpb(M, kpb_k, kpb_G)\n\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._check_dimensions_kpb-Tuple{Any, Any}","page":"Wannier90","title":"WannierIO._check_dimensions_kpb","text":"Check the dimensions between the quantities are consistent.\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._check_dimensions_Sx_Sy_Sz-Tuple{Any, Any, Any}","page":"Wannier90","title":"WannierIO._check_dimensions_Sx_Sy_Sz","text":"_check_dimensions_Sx_Sy_Sz(Sx, Sy, Sz)\n\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO._check_win_required_params-Tuple{Any}","page":"Wannier90","title":"WannierIO._check_win_required_params","text":"_check_win_required_params(kwargs)\n\n\n\n\n\n\n","category":"method"},{"location":"api/w90/#WannierIO.fix_win!-Tuple{Dict}","page":"Wannier90","title":"WannierIO.fix_win!","text":"fix_win!(params)\n\n\nSanity check and add missing input parameters from a win file.\n\nSee also read_win.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index-of-all-functions-and-types","page":"Index","title":"Index of all functions and types","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"Modules = [WannierIO]","category":"page"},{"location":"api/util/#Utility","page":"Utilities","title":"Utility","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Some simple convenience functions for development.","category":"page"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"CurrentModule = WannierIO","category":"page"},{"location":"api/util/#Fortran-related","page":"Utilities","title":"Fortran related","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Modules = [WannierIO]\nPages   = [\"util/fortran.jl\"]","category":"page"},{"location":"api/util/#WannierIO.isbinary-Tuple{AbstractString}","page":"Utilities","title":"WannierIO.isbinary","text":"isbinary(filename)\n\n\nCheck if the file is in binary format.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.isbinary-Tuple{AbstractVector{UInt8}}","page":"Utilities","title":"WannierIO.isbinary","text":"isbinary(chars)\n\n\nCheck if a sequence of chars is binary.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Lattice","page":"Utilities","title":"Lattice","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Modules = [WannierIO]\nPages   = [\"util/lattice.jl\"]","category":"page"},{"location":"api/util/#WannierIO.get_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utilities","title":"WannierIO.get_lattice","text":"get_lattice(recip_lattice)\n\n\nCompute lattice from reciprocal lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.get_recip_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utilities","title":"WannierIO.get_recip_lattice","text":"get_recip_lattice(lattice)\n\n\nCompute reciprocal lattice from lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Types","page":"Utilities","title":"Types","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Modules = [WannierIO]\nPages   = [\"common/type.jl\"]","category":"page"},{"location":"api/util/#WannierIO.FortranBinary","page":"Utilities","title":"WannierIO.FortranBinary","text":"Fortran unformatted IO.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.FortranBinaryStream","page":"Utilities","title":"WannierIO.FortranBinaryStream","text":"Fortran unformatted IO with stream access.\n\nFor example, file written using these Fortran code:\n\nOPEN(UNIT=11, FILE=\"ustream.demo\", STATUS=\"NEW\", ACCESS=\"STREAM\", FORM=\"UNFORMATTED\")\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.FortranText","page":"Utilities","title":"WannierIO.FortranText","text":"Fortran formatted IO.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.Mat3","page":"Utilities","title":"WannierIO.Mat3","text":"3 x 3 matrix type.\n\nFor lattice and recip_lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.Mat3-Tuple{AbstractVector}","page":"Utilities","title":"WannierIO.Mat3","text":"Vector{Vector} -> Mat3\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.SymbolVec3","page":"Utilities","title":"WannierIO.SymbolVec3","text":"Pair type associating a Symbol with a Vec3.\n\nFor win file atoms_frac and kpoint_path.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.Vec3","page":"Utilities","title":"WannierIO.Vec3","text":"Length-3 vector type.\n\nFor atom posistions, kpoints, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.Vec3-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utilities","title":"WannierIO.Vec3","text":"Mat3 -> Vec3{Vec3}\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.Wannier90Text","page":"Utilities","title":"WannierIO.Wannier90Text","text":"Plain text format for Wannier90 win and nnkp files.\n\nThe W90 default win or nnkp are plain text files but are not simple arrays of numbers that can be read by readdlm, therefore this struct is used to indicate that the file is plain text but need to be handled by corresponding functions, e.g., read_win, read_nnkp, etc.\n\nThis somewhat overlaps with FortranText, but this one is only used for small input parameter files e.g. win and nnkp (in comparison with the Wannier90Toml format), while the FortranText (in comparison with the FortranBinary format) is used for large matrices e.g. amn, mmn, eig, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#WannierIO.Wannier90Toml","page":"Utilities","title":"WannierIO.Wannier90Toml","text":"TOML file format for Wannier90 win and nnkp files.\n\nHere we introduce a TOML format for win and nnkp, so that once the win or nnkp files are converted into TOML, the TOML files can be loaded by standard TOML parsers without the headache of writing custom parsers in other Julia packages.\n\nSee also write_win, write_nnkp, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/util/#Constants","page":"Utilities","title":"Constants","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Modules = [WannierIO]\nPages   = [\"common/const.jl\"]","category":"page"},{"location":"api/util/#WannierIO.Bohr","page":"Utilities","title":"WannierIO.Bohr","text":"Bohr radius in Angstrom unit.\n\nThis is the default CODATA2006 value in W90 src/constants.F90.\n\n\n\n\n\n","category":"constant"},{"location":"api/util/#WannierIO.Bohr_QE","page":"Utilities","title":"WannierIO.Bohr_QE","text":"Bohr radius in Angstrom unit.\n\nThis is the default (Physical constants, SI (NIST 2018)) value in QE Modules/constants.f90.\n\n\n\n\n\n","category":"constant"},{"location":"api/util/#Misc","page":"Utilities","title":"Misc","text":"","category":"section"},{"location":"api/util/","page":"Utilities","title":"Utilities","text":"Modules = [WannierIO]\nPages   = [\"util/header.jl\", \"util/toml.jl\", \"util/parser.jl\", \"util/compare.jl\", \"WannierIO.jl\"]","category":"page"},{"location":"api/util/#WannierIO.default_header-Tuple{}","page":"Utilities","title":"WannierIO.default_header","text":"Default header for writing wannier90 files.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.write_toml-Tuple{Any}","page":"Utilities","title":"WannierIO.write_toml","text":"write_toml(io; kwargs...)\n\n\nWrite kwargs into io as a TOML file.\n\nDo some type conversion before writing.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.parse_bool-Tuple{AbstractString}","page":"Utilities","title":"WannierIO.parse_bool","text":"parse_bool(s)\n\n\nParse a string as bool.\n\nThis is capable of parsing Fortran outputs, e.g., .true., .false., true, T.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.parse_bool-Tuple{Integer}","page":"Utilities","title":"WannierIO.parse_bool","text":"parse_bool(i)\n\n\nParse an integer as bool.\n\n0: false\n1 or -1: true\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.parse_float-Tuple{AbstractString}","page":"Utilities","title":"WannierIO.parse_float","text":"parse_float(s)\n\n\nParse a string as Float64.\n\nThe is capable of parsing Fortran outputs, e.g. 1.0D-10, to the ordinary 1e-10.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.parse_indices-Tuple{AbstractString}","page":"Utilities","title":"WannierIO.parse_indices","text":"parse_indices(str)\n\n\nParse a string of comma-separated indices or range into a vector of integers.\n\nE.g., the exclude_bands tag of win file.\n\nExamples\n\njulia> parse_indices(\"1-2, 5,8 -10\")\n6-element Vector{Int64}:\n  1\n  2\n  5\n  8\n  9\n 10\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.parse_vector-Tuple{IO, Type, Integer}","page":"Utilities","title":"WannierIO.parse_vector","text":"parse_vector(io, T, n_elements)\n\n\nParse a vector of n_elements elements of type T from io.\n\nArguments\n\nio: input stream\nT: type of elements\nn_elements::Int: total number of elements\n\nExamples\n\nSuppose a file demo.txt has the following content:\n\n1  2  3  4  5  6  7  8  9  10\n11 12 13 14 15 16 17 18 19 20\n21 22 23\n\nThen the following code parses the file and return a vector filled with 1 to 23:\n\njulia> vector = open(\"demo.txt\") do io\n    parse_vector(io, Int, 23)\nend\n\nThe number of elements in each line can be different.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO._isapprox-Union{Tuple{T}, Tuple{T, T}} where T","page":"Utilities","title":"WannierIO._isapprox","text":"_isapprox(a, b)\n\n\nCompare two (same-type) structs.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#WannierIO.WannierIO","page":"Utilities","title":"WannierIO.WannierIO","text":"WannierIO.jl: a package for reading and writing Wannier90 file formats.\n\n\n\nWannierIO.jl\n\n(Image: Stable) (Image: Dev) (Image: CI) (Image: codecov)\n\nA Julia package for reading/writing Wannier90 file formats.\n\nThe package is designed to be minimalistic to allow easy reuse in other packages.\n\nQuick examples\n\nusing WannierIO\n\nA = read_amn(\"silicon.amn\")\nwrite_amn(\"silicon_2.amn\", A)\n\nchk = read_chk(\"silicon.chk\")\nwrite_chk(\"silicon_2.chk\", chk; binary=true)\n\nRelated packages\n\nWannier.jl: Wannierization and Wannier interpolation.   The IO part of Wannier.jl was isolated and moved into this package.\n\n\n\nExported functions:\n\nget_U\nget_Udis\nread_amn\nread_bxsf\nread_chk\nread_cube\nread_eig\nread_mmn\nread_nnkp\nread_spn\nread_uHu\nread_unk\nread_w90_band\nread_w90_band_dat\nread_w90_band_kpt\nread_w90_band_labelinfo\nread_w90_hrdat\nread_w90_rdat\nread_w90_tbdat\nread_w90_wsvec\nread_win\nread_wout\nread_xsf\nwrite_amn\nwrite_bxsf\nwrite_chk\nwrite_cube\nwrite_eig\nwrite_mmn\nwrite_nnkp\nwrite_spn\nwrite_uHu\nwrite_unk\nwrite_w90_band\nwrite_w90_band_dat\nwrite_w90_band_kpt\nwrite_w90_band_labelinfo\nwrite_w90_hrdat\nwrite_w90_tbdat\nwrite_w90_wsvec\nwrite_win\nwrite_xsf\n\n\n\n\n\n","category":"module"},{"location":"api/convention/#Conventions","page":"Convention","title":"Conventions","text":"","category":"section"},{"location":"api/convention/#Units","page":"Convention","title":"Units","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"In most cases, the units of the function arguments and returned values are in angstrom for lattice, and fractional (w.r.t. lattice) for atomic positions, etc.","category":"page"},{"location":"api/convention/#Variables","page":"Convention","title":"Variables","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Here are some variable conventions used throughout the code and documentation.","category":"page"},{"location":"api/convention/#Names","page":"Convention","title":"Names","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"U: unitary transformation matrices\nA: to differentiate between U, some times we use A specifically for the initial projection matrix, i.e., amn of Wannier90\nM: overlap matrices between neighboring kpoints, i.e., mmn of Wannier90","category":"page"},{"location":"api/convention/#Dimensions","page":"Convention","title":"Dimensions","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Prefixed by n_, indicating this is an integer specifying the length of some quantities; then followed by a short acronym of the quantity, to avoid typing long names repeatedly.","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"n_bands: number of bands\nn_wann: number of WFs\nn_kpts: number of kpoints\nn_bvecs: number of b-vectors\nn_atoms: number of atoms","category":"page"},{"location":"api/convention/#Indices","page":"Convention","title":"Indices","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Usually, the returned quantities are Vectors of some types (Matrix{Float64}, Vector{Float64}, etc), and the indices follow the order of","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"kpoints\nb-vectors (if needed)\nbands\nWannier functions","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"For instance, the energy eigenvalues eigenvalues is a length-n_kpts vector, with each element a length-n_bands vector of floats, i.e., eigenvalues[ik][ib] is the ib-th eigenvalue at ik-th kpoint.","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Here are some examples of indexing the vectors:","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"eigenvalues[ik][m] for energy eigenvalues varepsilon_m mathbfk\nU[ik][m, n] for the gauge matrix U_mn mathbfk\nM[ik][ib][m, n] for the overlap matrix M_mn mathbfk mathbfk + mathbfb","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"where","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"ik: index of kpoints\nib: index of b-vectors\nm: index of bands\nn: index of Wannier functions","category":"page"},{"location":"api/convention/#Functions","page":"Convention","title":"Functions","text":"","category":"section"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"In most cases, there are some multiple dispatches for the same function. For instance, there are three functions for reading the chk file:","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"read_chk(filename::AbstractString)\nread_chk(filename::AbstractString, ::FortranText)\nread_chk(filename::AbstractString, ::FortranBinary)","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Why do we need several functions for reading the same format? The reasons are:","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Wannier90 is a Fortran code that accepts both Fortran text format and binary format (or called Fortran formatted and unformatted file, respectively). To avoid introducing lots of different function names for reading text or binary files, we use multiple dispatch to distinguish them: the type of the 2nd argument (FortranText or FortranBinary) is used to distinguish the file type we want to read.\nHowever, asking the user to manually specify the file format is tedious, therefore, we provide a high-level user-friendly function (the 1st one), which\nautomatically detects the file format and calls the corresponding low-level (2nd or 3rd) function\nprints some information of key quantities of the file, e.g., number of kpoints, number of Wannier functions, etc., to give user a hint of what have been parsed\nhides some irrelevant return values, e.g., the header (the 1st line) of the file, since it has been printed in the stdout\nThe low-level functions parse everything in the file, while the high-level function aims at user ergonomics.","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Thus,","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"In most cases using the high-level function is enough, e.g.,\njulia> using WannierIO\njulia> A = read_amn(\"si2.amn\")\n┌ Info: Reading amn file\n│   filename = \"si2.amn\"\n│   header = \"Created on  9Sep2022 at 16:41: 5\"\n│   n_kpts = 8\n│   n_bands = 4\n└   n_wann = 4\n8-element Vector{Matrix{ComplexF64}}:\n [...]\nUse the low-level functions if you\nwant to get the header of the file (or quantities not returned by high-level function)\ndo not want stdout to be \"polluted\"\njulia> using WannierIO\njulia> A, header = read_amn(\"si2.amn\", WannierIO.FortranText())\njulia> typeof(A)\nVector{Matrix{ComplexF64}} (alias for Array{Array{Complex{Float64}, 2}, 1})\njulia> header\n\"Created on  9Sep2022 at 16:41: 5\"","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Note that usually the high-level function directly returns the quantities, e.g., a single A to avoid the user unpacking return values; however, often the low-level functions return a NamedTuple of all the quantities, for the sake of clarity.","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"julia> amn = read_amn(\"si2.amn\", WannierIO.FortranText())\njulia> typeof(amn)\nNamedTuple{(:A, :header), Tuple{Vector{Matrix{ComplexF64}}, SubString{String}}}","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"Of course, when using low-level functions you can also directly access the quantity without unpacking by","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"julia> A = read_amn(\"si2.amn\", WannierIO.FortranText()).A","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"When writing files, the user can specify whether to write in text or binary by a keyword argument binary of the high-level function","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"julia> write_amn(\"si2.amn\", A; binary=true)","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"The binary keyword argument avoids the user specifying the file type when calling the low-level functions, e.g.,","category":"page"},{"location":"api/convention/","page":"Convention","title":"Convention","text":"julia> write_amn(\"si2.amn\", A, WannierIO.FortranBinaryStream())","category":"page"},{"location":"api/qe/#Quantum-ESPRESSO-files","page":"Quantum ESPRESSO","title":"Quantum ESPRESSO files","text":"","category":"section"},{"location":"api/qe/","page":"Quantum ESPRESSO","title":"Quantum ESPRESSO","text":"CurrentModule = WannierIO","category":"page"},{"location":"api/qe/","page":"Quantum ESPRESSO","title":"Quantum ESPRESSO","text":"Modules = [WannierIO]\nPages   = [\n    \"qe/band.jl\",\n    \"qe/xml.jl\",\n]","category":"page"},{"location":"api/qe/#WannierIO.guess_kpath-Tuple{AbstractVector{<:AbstractVector}}","page":"Quantum ESPRESSO","title":"WannierIO.guess_kpath","text":"guess_kpath(kpoints; atol)\n\n\nGuess high symmetry points from kpoint coordinates.\n\nIf there is angle between two consecutive kpoints, then it is labeled as a high-symmetry point.\n\nArguments\n\nkpoints: Vector of Vector or Vec3, in Cartesian coordinates\n\nKeyword Arguments\n\natol: Absolute tolerance for checking cross product of two vectors\n\nReturns\n\nsymm_point_indices: Vector of indices of high-symmetry points\nsymm_point_labels: Vector of labels of high-symmetry points, for the moment it is empty\n\n\n\n\n\n","category":"method"},{"location":"api/qe/#WannierIO.read_qe_band-Tuple{AbstractString}","page":"Quantum ESPRESSO","title":"WannierIO.read_qe_band","text":"read_qe_band(filename)\n\n\nRead Quantum ESPRESSO bands.x output data file.\n\nThe data file has format\n\n &plot nbnd=  20, nks=   380 /\n           -0.500000  0.500000  0.500000\n   -3.320   -0.666    5.173    5.173    7.994    9.725    9.725   14.147   16.993   16.993\n   17.841   17.841   17.902   19.666   25.961   26.563   28.186   28.186   28.368   28.368\n           -0.495000  0.495000  0.495000\n   -3.322   -0.664    5.173    5.173    7.994    9.725    9.725   14.148   16.980   16.980\n...\n\n\n\n\n\n","category":"method"},{"location":"api/qe/#WannierIO.read_qe_xml-Tuple{AbstractString}","page":"Quantum ESPRESSO","title":"WannierIO.read_qe_xml","text":"read_qe_xml(filename)\n\n\nRead atomic structure and band structure from QE's XML output.\n\nReturn\n\nlattice: 3 * 3, Å, each column is a lattice vector\natom_positions: length-n_atoms vector, each element is a fractional position\natom_labels: length-n_atoms vector, each element is the label of the corresponding atom\nrecip_lattice: 3 * 3, Å⁻¹, each column is a reciprocal lattice vector\nkpoints: length-n_kpts vector, each element is a fractional kpoint\nfermi_energy: eV\nalat: the alat of QE in Å\neigenvalues: length-n_kpts vector, each element is a length-n_bands vector of   eigenvalue in eV. For spin-polarized but without SOC calculations,   return two arries of eigenvalues_up and eigenvalues_dn for the two spin channels.\n\n\n\n\n\n","category":"method"},{"location":"#WannierIO.jl","page":"Home","title":"WannierIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for reading/writing Wannier90 files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is designed to be minimalistic to allow easy reuse in other packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package originates from the IO part of the Wannier.jl package.","category":"page"},{"location":"#Wannier90-files","page":"Home","title":"Wannier90 files","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Input files:","category":"page"},{"location":"","page":"Home","title":"Home","text":"amn\nmmn\neig\nchk\nUNK\nspn","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also support parsing both plain text and binary formats (in Fortran language, called formatted and unformatted IO, respectively) for some files, e.g., chk and UNK.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Output files:","category":"page"},{"location":"","page":"Home","title":"Home","text":"*_band.dat\n*_tb.dat\n*_wsvec.dat\n*_hr.dat\n*_r.dat\nxsf\ncube\n...","category":"page"},{"location":"#Quantum-ESPRESSO-files","page":"Home","title":"Quantum ESPRESSO files","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To support comparing Wannier-interpolated band structures with density function theory (DFT) bands, there are also some functions to parse Quantum ESPRESSO (QE) output files:","category":"page"},{"location":"","page":"Home","title":"Home","text":"xml\nbands.dat generated by QE bands.x","category":"page"},{"location":"api/volumetric/#Volumetric-data-files","page":"Volumetric data","title":"Volumetric data files","text":"","category":"section"},{"location":"api/volumetric/","page":"Volumetric data","title":"Volumetric data","text":"CurrentModule = WannierIO","category":"page"},{"location":"api/volumetric/#Read/write","page":"Volumetric data","title":"Read/write","text":"","category":"section"},{"location":"api/volumetric/","page":"Volumetric data","title":"Volumetric data","text":"Modules = [WannierIO]\nPages   = [\n    \"volume/xsf.jl\",\n    \"volume/bxsf.jl\",\n    \"volume/cube.jl\",\n]","category":"page"},{"location":"api/volumetric/#WannierIO.read_xsf-Tuple{AbstractString}","page":"Volumetric data","title":"WannierIO.read_xsf","text":"read_xsf(filename)\n\n\nRead xsf file.\n\nReturn\n\nprimvec: 3 * 3, Å, each column is a primitive lattice vector\nconvvec: 3 * 3, Å, each column is a conventional lattice vector\natoms: n_atoms String, atomic symbols or numbers\natom_positions: length-n_atoms vector, Å, cartesian coordinates\norigin: 3, Å, origin of the grid\nspan_vectors: 3 * 3, Å, each column is a spanning vector\nX: nx, fractional coordinate of grid points along the first spanning vector\nY: ny, fractional coordinate of grid points along the second spanning vector\nZ: nz, fractional coordinate of grid points along the third spanning vector\nW: nx * ny * nz, volumetric data\n\nnote: Note\nOnly support reading 1 datagrid in BLOCK_DATAGRID_3D.\n\n\n\n\n\n","category":"method"},{"location":"api/volumetric/#WannierIO.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, AbstractVector{T}, AbstractMatrix{T}, AbstractArray{T, 3}}} where T<:Real","page":"Volumetric data","title":"WannierIO.write_xsf","text":"write_xsf(\n    filename,\n    lattice,\n    atom_positions,\n    atom_numbers,\n    origin,\n    span_vectors,\n    W\n)\n\n\nWrite xsf file.\n\nArguments\n\nlattice: 3 * 3, Å, each column is a lattice vector\natom_positions: length-n_atoms vector, fractional coordinates\natom_numbers: n_atoms, atomic numbers\norigin: 3, Å, origin of the grid\nspan_vectors: 3 * 3, Å, each column is a spanning vector\nW: nx * ny * nz, volumetric data\n\n\n\n\n\n","category":"method"},{"location":"api/volumetric/#WannierIO.read_bxsf-Tuple{AbstractString}","page":"Volumetric data","title":"WannierIO.read_bxsf","text":"read_bxsf(filename)\n\n\nRead bxsf file.\n\nReturn\n\nfermi_energy: Fermi energy in eV\norigin: 3, Å⁻¹, origin of the grid\nspan_vectors: 3 * 3, Å⁻¹, each column is a spanning vector\nX: nx, fractional coordinate of grid points along the first spanning vector\nY: ny, fractional coordinate of grid points along the second spanning vector\nZ: nz, fractional coordinate of grid points along the third spanning vector\nE: n_bands * nx * ny * nz, eigenvalues at each grid point\n\n\n\n\n\n","category":"method"},{"location":"api/volumetric/#WannierIO.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, T, AbstractVector{T}, AbstractMatrix{T}, AbstractArray{T, 4}}} where T<:Real","page":"Volumetric data","title":"WannierIO.write_bxsf","text":"write_bxsf(filename, fermi_energy, origin, span_vectors, E)\n\n\nWrite bxsf file.\n\nArguments\n\nfermi_energy: Fermi energy in eV\norigin: 3, Å⁻¹, origin of the grid\nspan_vectors: 3 * 3, Å⁻¹, each column is a spanning vector\nE: n_bands * nx * ny * nz, eigenvalues at each grid point\n\n\n\n\n\n","category":"method"},{"location":"api/volumetric/#WannierIO.read_cube-Tuple{AbstractString}","page":"Volumetric data","title":"WannierIO.read_cube","text":"read_cube(filename)\n\n\nRead cube file.\n\nnote: Note\nBy default, cube use Bohr unit, here all returns are in Cartesian coordinates, Å unit.\n\n\n\n\n\n","category":"method"},{"location":"api/volumetric/#WannierIO.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, AbstractMatrix{T}, AbstractArray{T, 3}}} where T<:Real","page":"Volumetric data","title":"WannierIO.write_cube","text":"write_cube(\n    filename,\n    atom_positions,\n    atom_numbers,\n    origin,\n    span_vectors,\n    W\n)\n\n\nWrite cube file.\n\nArguments\n\natom_positions: 3 * n_atoms, Å, cartesian coordinates\natom_numbers: n_atoms, atomic numbers\norigin: 3, Å, origin of the grid\nspan_vectors: 3 * 3, Å, each column is a spanning vector\nW: nx * ny * nz, volumetric data\n\n\n\n\n\n","category":"method"},{"location":"api/epw/#EPW-files","page":"EPW","title":"EPW files","text":"","category":"section"},{"location":"api/epw/","page":"EPW","title":"EPW","text":"CurrentModule = WannierIO","category":"page"},{"location":"api/epw/","page":"EPW","title":"EPW","text":"Modules = [WannierIO]\nPages   = [\n    \"misc/epw.jl\",\n]","category":"page"},{"location":"api/epw/#WannierIO.Ukk","page":"EPW","title":"WannierIO.Ukk","text":"Struct for the EPW .ukk file.\n\nSimilar to the W90 .chk file.\n\nstruct Ukk{T<:Real}\n\nFields\n\nibndstart: index of the first band\nibndend: index of the last band\nn_kpts: number of kpoints\nn_bands: number of bands\nn_wann: number of wannier functions\nU: gauge matrices, length-n_kpts vector, each element is a n_bands * n_wann matrix\nfrozen_bands: flag for frozen bands, length-n_kpts vector, each element is a length-n_bands vector\nexcluded_bands: flag for excluded bands, length-n_bands + n_excl_bands vector, where n_excl_bands is the number of excluded bands\ncenters: centers of WFs, length-n_wann vector of Vec3. Note that EPW uses Cartesian coordinates w.r.t the QE alat, so it is dimensionless.\n\n\n\n\n\n","category":"type"},{"location":"api/epw/#WannierIO.Ukk-Tuple{WannierIO.Chk, Real}","page":"EPW","title":"WannierIO.Ukk","text":"Ukk(chk, alat)\n\n\nConstruct a EPW Ukk from a W90 Chk.\n\nArguments\n\nchk: the Chk struct\nalat: the QE alat in Å unit. Note that the alat from QE stdout file is   in Bohr unit, you need to do the conversion by multiplying it with   Bohr_QE.\n\nExamples\n\nConvert a W90 .chk file to a EPW .ukk file:\n\nusing WannierIO\nchk = read_chk(\"BN.chk\")\n# Note we need QE `alat` for ukk. You can get it\n# - either by inspecting the QE stdout file, from line like\n#       lattice parameter (alat)  =       6.8330  a.u.\n#   where the 6.8330 is the alat in Bohr unit. However, the Bohr constant\n#   in W90 and QE are slightly different, to be exact we need to do the unit\n#   conversion using QE constant:\nalat = 6.8330 * WannierIO.Bohr_QE\n# - or better by parsing the QE xml file, and the unit conversion is done automatically\nalat = read_qe_xml(\"BN.xml\").alat\nukk = Ukk(chk, alat)\nWannierIO.write_epw_ukk(\"BN.ukk\", ukk)\n\n\n\n\n\n","category":"method"},{"location":"api/epw/#Base.isapprox-Tuple{WannierIO.Ukk, WannierIO.Ukk}","page":"EPW","title":"Base.isapprox","text":"isapprox(a, b)\n\n\nCompare two Ukk structs.\n\n\n\n\n\n","category":"method"},{"location":"api/epw/#WannierIO.read_epw_mmn-Tuple{AbstractString}","page":"EPW","title":"WannierIO.read_epw_mmn","text":"read_epw_mmn(filename; n_kpts, n_bvecs, n_bands)\n\n\nRead the EPW mmn file.\n\nThe EPW mmn format is different from that of W90. It does not contain the number of kpoints/bvectors/bands, so they need to be provided as keyword arguments.\n\nArguments\n\nfilename: the mmn file name\n\nKeyword arguments\n\nn_kpts: number of kpoints\nn_bvecs: number of bvectors\nn_bands: number of bands\n\nReturn\n\nM: length-n_kpts vector of length-n_bvecs vector of n_bands * n_bands matrices\n\n\n\n\n\n","category":"method"},{"location":"api/epw/#WannierIO.read_epw_ukk-Tuple{AbstractString}","page":"EPW","title":"WannierIO.read_epw_ukk","text":"read_epw_ukk(filename)\n\n\nRead the EPW .ukk file.\n\nArguments\n\nfilename: the output file name\n\nReturn\n\nukk: the Ukk struct\n\n\n\n\n\n","category":"method"},{"location":"api/epw/#WannierIO.write_epw_ukk-Tuple{AbstractString, WannierIO.Ukk}","page":"EPW","title":"WannierIO.write_epw_ukk","text":"write_epw_ukk(filename, ukk)\n\n\nWrite the EPW .ukk file.\n\nArguments\n\nfilename: the output file name\nukk: the Ukk struct\n\nExamples\n\nSee Ukk(chk::Chk, alat::Real) for how to construct a Ukk from a Chk.\n\n\n\n\n\n","category":"method"}]
}
